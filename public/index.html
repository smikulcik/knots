<html>
  <head>
  <style>
    body {
      margin: 0px;
      padding: 0px;
    }
    #myCanvas {
      border: 1px solid #9C98ff;
    }
  </style>
  <script>

    // bezier utils
    function splitQuadBezier(p, u) {
      // from https://pages.mtu.edu/~shene/COURSES/cs3621/NOTES/spline/Bezier/bezier-sub.html

      const n = p.length
      const d = new Array(n*n) // deCasteljauTriange
      const right = new Array(n)
      const left = new Array(n)
      
      // populate initial conditions
      for(let i=0;i<n;i++){
        d[i] = p[i] // d[0, i] = p[i]
      }

      // fill out triangle split by u
      for(let i=1; i<n;i++){
        for(let j=0; j<n-i;j++){
          // d[i, j] = d[i-1, j]*u + d[i-1, j+1]*(1-u)
          d[i*n + j] = {
            x: d[(i-1)*n + j].x*u + d[(i-1)*n + (j+1)].x*(1-u),
            y: d[(i-1)*n + j].y*u + d[(i-1)*n + (j+1)].y*(1-u)
          }
        }
      }

      // output final array
      for(let i=0;i<n;i++){
        // copy in top triange side
        right[i] = d[i*n + 0]
      }
      for(let i=n-1;i>=0;i--){
        // copy in bottom triangle side
        const j = (n-1) - i
        left[j] = d[i*n + j]
      }
      return [right, left]
    }

    // matrix and vector utils
    class Mat {
      constructor(rows, cols, data){
        this.rows = rows
        this.cols = cols
        this.data = data
      }
    }
    function vdot(a, b){
      return a.x*b.x + a.y*b.y + (a.z*b.z || 0)
    }
    function vcross(a, b){
      return {
        x: (a.y*b.z) - (a.z*b.y),
        y: (a.z*b.x) - (a.x*b.z),
        z: (a.x*b.y) - (a.y*b.x)
      }
    }
    function normalize(v){
      const mag = Math.sqrt(v.x*v.x + v.y*v.y)
      return {
        x: v.x/mag,
        y: v.y/mag
      }
    }
    function matMul(a, b){
      const out = new Array(a.rows * b.cols)

      for(let aRow = 0;aRow<a.rows;aRow++){
        for(let bCol = 0; bCol<b.cols; bCol++){
          out[aRow*a.cols+bCol] = 0
          for(let i=0;i<a.cols;i++){
            out[aRow*a.cols+bCol] += a.data[aRow*a.cols+i]*b.data[i*b.cols+bCol]
          }
        }
      }
      return new Mat(a.rows, b.cols, out)
    }
    function vsub(a, b){
      return {
        x: a.x - b.x,
        y: a.y - b.y,
        z: a.z ? a.z - b.z : 0
      }
    }
    function vadd(a, b){
      return {
        x: a.x + b.x,
        y: a.y + b.y,
        z: a.z ? a.z + b.z : 0
      }
    }
    function vscalar(s, a){
      return {
        x: a.x*s,
        y: a.y*s,
        z: a.z ? a.z*s : 0
      }
    }
    function vmag(v){
      return Math.sqrt(v.x*v.x + v.y*v.y + (v.z*v.z || 0))
    }
    // compute tangent vector from p1 in relation to line
    // p0->p1->p2
    function vtangent(p0, p1, p2){
      const ab = vsub(p1, p0)
      const cb = vsub(p1, p2)

      // find bisect vector
      const bisect = vadd(normalize(ab), normalize(cb))

      // find cross-product vector
      const cross = vcross(ab, cb)

      // tangent is cross-product cross bisect
      return vcross(bisect, cross)
    }
    function project(p, v0, v){
      const pMag = vdot(vsub(p, v0), v)/vmag(v)
      const vHat = normalize(v)
      return {
        x: v0.x + vHat.x*pMag,
        y: v0.y + vHat.y*pMag
      }
    }
    // console.log('proj', project({x: 1, y: 2}, {x: 1, y: 0}, {x: 2, y: 2}))
    // const x = new Mat(2,2, 
    //   [1,2,
    //    3,4])
    // const y = new Mat(2,2,
    //   [5,6,
    //    7,8])
    // console.log('x', x, y, matMul(x, y))

    function angMagFrom(a, angle, magnitude) {
      return {
        x: a.x + magnitude*Math.cos(angle*Math.PI/180.0),
        y: a.y + magnitude*Math.sin(angle*Math.PI/180.0),
      }
    }

    // drawing utils
    function circle(context, c, radius, color){
      context.beginPath();
      context.arc(c.x, c.y, radius, 0, 2 * Math.PI, false);
      context.fillStyle = color;
      context.fill();
      // context.lineWidth = 5;
      // context.strokeStyle = '#003300';
      // context.stroke();
    }
    function line(context, s, e, lineWidth, color){
      return bezier(context, [s, s, e, e], lineWidth, color)
    }
    function bezier(context, points, lineWidth, color){
      const [s, c1, c2, e] = points

      context.beginPath()
      context.moveTo(s.x, s.y)
      context.lineWidth = lineWidth
      context.strokeStyle = color
      context.bezierCurveTo(c1.x, c1.y, c2.x, c2.y, e.x, e.y)
      context.stroke()
    }

    // knot data
    const knot = [
      {
        x: 200,
        y: 100,
        a: {
          a: -20, // angle in degrees
          m1: 50, // outbound magnitude
          m2: -100, // inbound magnitude 
          n: {i: 1,x: 'a'}
        },
        b: {
          a: 270, // angle in degrees
          m1: 75, // outbound magnitude
          m2: -50, // inbound magnitude 
          n: {i: 1,x: 'b'}
        },
        top: 'a'
      },
      {
        x: 400,
        y: 100,
        a: {
          a: 20, // angle in degrees
          m1: 100, // outbound magnitude
          m2: -50, // inbound magnitude 
          n: {i: 2,x: 'a'}
        },
        b: {
          a: 90, // angle in degrees
          m1: 50, // outbound magnitude
          m2: -75, // inbound magnitude 
          n: {i: 2,x: 'b'}
        },
        top: 'b'
      },
      {
        x: 300,
        y: 250,
        a: {
          a: 210, // angle in degrees
          m1: 50, // outbound magnitude
          m2: -100, // inbound magnitude 
          n: {i: 0,x: 'b'}
        },
        b: {
          a: 150, // angle in degrees
          m1: 100, // outbound magnitude
          m2: -50, // inbound magnitude 
          n: {i: 0,x: 'a'}
        },
        top: 'a'
      }
    ]
    window.onload = function () {
      var canvas = document.getElementById("canvas")
      var context = canvas.getContext("2d")

      context.fillStyle = "#eeeeee"
      context.strokeStyle = '#000000'
      context.rect(0, 0, 800, 600)
      context.fill()

      for (const layer of ['bottom', 'top']){
        let cur = {
          i: 0,
          x: 'a'
        }
        let lineWidth=20
        do {
          // start and end
          const start = knot[cur.i]
          const nxt = start[cur.x].n
          const end = knot[nxt.i]

          // control points from angle
          const c1 = angMagFrom(start, start[cur.x].a, start[cur.x].m1)
          const c2 = angMagFrom(end, end[nxt.x].a, end[nxt.x].m2)

          // draw curve
          const [left, right] = splitQuadBezier([start, c1, c2, end], .5)
          if (// draw left if on layer bottom and it's bottom or layer top and it's top
            start.top !== cur.x && layer === 'bottom' ||
            start.top === cur.x && layer === 'top' 
          ){
            bezier(context, left, lineWidth, '#000000')
            bezier(context, left, lineWidth-3, '#ffffff')
          }
          if (// draw left if on layer bottom and it's bottom or layer top and it's top
            end.top !== nxt.x && layer === 'bottom' ||
            end.top === nxt.x && layer === 'top' 
          ){
            bezier(context, right, lineWidth, '#000000')
            bezier(context, right, lineWidth-3, '#ffffff')
          }

          cur = knot[cur.i][cur.x].n
        } while (cur.i !== 0 || cur.x !== 'a') // continue until we get to the start
      }
      // draw control points
      for(const crossover of knot){
        const a1 = angMagFrom(crossover, crossover.a.a, crossover.a.m1)
        const a2 = angMagFrom(crossover, crossover.a.a, crossover.a.m2)
        const b1 = angMagFrom(crossover, crossover.b.a, crossover.b.m1)
        const b2 = angMagFrom(crossover, crossover.b.a, crossover.b.m2)

        // draw control point lines
        line(context, crossover, a1, 1, '#008800')
        circle(context, a1, 3, '#008800')

        line(context, crossover, a2, 1, '#008800')
        circle(context, a2, 3, '#008800')

        line(context, crossover, b1, 1, '#008800')
        circle(context, b1, 3, '#008800')

        line(context, crossover, b2, 1, '#008800')
        circle(context, b2, 3, '#008800')
      }
    }
  </script>
  </head>
  <body>
  <canvas id="canvas" width="800" height="600"></canvas>
  </body>
</html>
